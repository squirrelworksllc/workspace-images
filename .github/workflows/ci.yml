# This is the main CI enforcement workflow for the entire repository. Do not modify it!
name: ci

on:
  pull_request:
  push:
    branches: ["main"]

permissions:
  contents: read

jobs:
  # 1) Build a dynamic matrix from .vscode/images.json
  matrix:
    name: generate matrix
    runs-on: ubuntu-latest
    outputs:
      include: ${{ steps.gen.outputs.include }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate include matrix from .vscode/images.json
        id: gen
        shell: bash
        run: |
          set -euo pipefail

          # include = [{key, dockerfile, repo, prodTag, devTarget, lintTarget}]
          include="$(jq -c '
            { include: [
              .images[] | {
                key,
                dockerfile,
                repo,
                prodTag,
                devTarget,
                lintTarget
              }
            ] }' .vscode/images.json)"

          echo "include=$include" >> "$GITHUB_OUTPUT"
          echo "$include" | jq .

  # 2) Lint each image (Dockerfile + scripts)
  lint:
    name: lint (${{ matrix.key }})
    runs-on: ubuntu-latest
    needs: [matrix]
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix.outputs.include) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Lint target (no cache, plain output)
        shell: bash
        run: |
          set -euo pipefail
          echo "Dockerfile: ${{ matrix.dockerfile }}"
          DOCKER_BUILDKIT=1 docker build \
            --progress=plain \
            --no-cache \
            --target "${{ matrix.lintTarget }}" \
            -f "${{ matrix.dockerfile }}" \
            .

  # 2b) Lint gate (single stable required check)
  lint-gate:
    name: lint / gate
    runs-on: ubuntu-latest
    needs: [lint]
    if: always()
    steps:
      - name: Fail if any lint job failed
        shell: bash
        run: |
          set -euo pipefail
          echo "lint result: ${{ needs.lint.result }}"
          test "${{ needs.lint.result }}" = "success"

  # 3) Optional: Build production for every image (proves it actually builds)
  build-production:
    name: build production (${{ matrix.key }})
    runs-on: ubuntu-latest
    needs: [matrix]
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix.outputs.include) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build production (no push)
        shell: bash
        run: |
          set -euo pipefail
          echo "Dockerfile: ${{ matrix.dockerfile }}"
          echo "Building: ${{ matrix.repo }}:${{ matrix.prodTag }}"
          DOCKER_BUILDKIT=1 docker build \
            --progress=plain \
            -t "${{ matrix.repo }}:${{ matrix.prodTag }}" \
            -f "${{ matrix.dockerfile }}" \
            .

  # 3b) Build gate (single stable required check)
  build-production-gate:
    name: build production / gate
    runs-on: ubuntu-latest
    needs: [build-production]
    if: always()
    steps:
      - name: Fail if any production build job failed
        shell: bash
        run: |
          set -euo pipefail
          echo "build-production result: ${{ needs.build-production.result }}"
          test "${{ needs.build-production.result }}" = "success"